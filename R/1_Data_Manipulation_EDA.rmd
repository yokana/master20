---
title: "EDA"
author: "Johannes Wagner"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, include=FALSE}
library(tidyverse)
library(doBy)
library(broom)
library("data.table")
library(magrittr) 
library(gtools) # various programming tools
library("robCompositions") # for compData analysis
library(compositions)
library(ggplot2) # for plots
library(gridExtra) # for several plots in one window
```

This document is aiming to provide a first insight into the dataset of the STAR project. The first part contains the necessary data manipulation, which can be skipped. The relevant code can be viewed by checking the `Code` snippets. The second part contains some basic explaratory analysis, which mostly follows the papers from Krüger et al. (1999 and 2001).


```{r echo=TRUE}
# rename our dataset  
load("/home/hanes/Documents/Projects/2020_Master_STAR/master20/data/STAR_Students.RData")
# rename and drop observation with only NAs
main_data <- x %>% filter(!is.na(stdntid))
# %>% select(c(stdntid, gender, race, X, X.1, X.2,X.3, gktchid)
main_data_gk <- 
  main_data %>% filter(X=="YES")
main_data_g1 <- 
  main_data %>% filter(X=="YES" | X.1=="YES")
main_data_g2 <- 
  main_data %>% filter(X=="YES" | X.1=="YES" | X.2=="YES")
main_data_g3 <- 
  main_data %>% filter(X=="YES" | X.1=="YES" | X.2=="YES" | X.3=="YES")

```

# Data Manipulation

### Percentile Ranks

One main question is how to compute the dependent variable `percentile ranks`. Following I repeat the computing steps that Krüger lays out in his paper from 1999. Brief explanations can be found inside the code.

Percentage ranks are first computed for all students in regular classes and then the students, who were assigned to small classes, are given their ranks relative to the ranks of the distribution of regular students. Test scores are available for math, reading and word compehension. Following the mean values for each group of students and each subject are displayed. For computation the `percent_rank()` function from the `dplyr` package was used. The function gives the lower percentile rank to students with equal score, which probably explains why the mean values for regular students (baseline) are lower than 0.5.


```{r echo=TRUE}
# See Krüger_199, p. 506ff
reg_scores_gk <- 
  main_data_gk %>% filter(gkclasstype=="REGULAR CLASS" | gkclasstype=="REGULAR + AIDE CLASS", !is.na(gktmathss) & !is.na(gktreadss) & !is.na(gkwordskillss) ) %>%
    select(stdntid,gkclasstype,gktmathss,gktreadss, gkwordskillss )

small_scores_gk <- 
  main_data_gk %>% filter(gkclasstype=="SMALL CLASS", !is.na(gktmathss) & !is.na(gktreadss) & !is.na(gkwordskillss) )  %>%
    select(stdntid,gkclasstype,gktmathss,gktreadss, gkwordskillss )
# calculate raw percentiles and plot them (should be uniform)
# there are different options available: with percent rank equal scores get the lower percentile (thats why we dont exactually get a uniform distribution of actual percentiles)
reg_scores_gk <- 
  reg_scores_gk %>% mutate(perc_maths_gk=percent_rank(gktmathss), perc_read_gk =percent_rank(gktreadss), perc_word_gk=percent_rank(gkwordskillss))
# summary(reg_data_gk$raw_perc_maths); summary(reg_data_gk$raw_perc_maths2)
# Why is mean not 0.5???
# hist(summary(reg_data_gk$raw_perc_maths2))

# Let's use an own function which just divides rank by length and then compares ranks of students in SMALL classes to those in regular classes
# make a new dataset and add each observation of SMALL class after computing percentile relative to regular class students
scores_gk <- reg_scores_gk

for (i in 1:nrow(small_scores_gk)) {
  # select ith observation
  obs <- small_scores_gk[i,]
  # add to regular observations and compute percentile ranks
  temp <- add_row(reg_scores_gk, obs) %>% 
    mutate(perc_maths_gk=percent_rank(gktmathss), perc_read_gk =percent_rank(gktreadss), perc_word_gk=percent_rank(gkwordskillss))
  # add observation to merged scores
  scores_gk <-  add_row(scores_gk, tail(temp,1))
}
# for loop needs forever since all datasets have to be loaded each time, can we use something like lapply?

# calculate average of the scores
scores_gk <- 
  scores_gk %>% mutate(perc_average_gk = (perc_maths_gk + perc_read_gk + perc_word_gk)/3)
# summary(scores_gk$perc_average_gk)
# hist(scores_gk$perc_average_gk)

# Calculate Summary Statistics (See: Krüger (1999), p. 508)
scores_gk %>% 
  filter(gkclasstype=="REGULAR CLASS" | gkclasstype=="REGULAR + AIDE CLASS") %>%
    summarise(mean_av = mean(perc_average_gk), mean_math = mean(perc_maths_gk), mean_read = mean(perc_read_gk), mean_word = mean(perc_word_gk))
scores_gk %>% 
  filter(gkclasstype=="SMALL CLASS") %>%
    summarise(mean_av = mean(perc_average_gk), mean_math = mean(perc_maths_gk), mean_read = mean(perc_read_gk), mean_word = mean(perc_word_gk))
# We can already see that SMALL classes seem to have a positive impact on average (interestingly biggest effect on reading abilities (kind of makes sense))
```

The results for kindergarten students already show a positive effect of *SMALL* classes.

The computation is repeated for 1st, 2nd and 3rd Grade:

```{r echo=TRUE}
reg_scores_g1 <- 
  main_data_g1 %>% filter(g1classtype=="REGULAR CLASS" | g1classtype=="REGULAR + AIDE CLASS", !is.na(g1tmathss) & !is.na(g1treadss) & !is.na(g1wordskillss) )  %>%
    select(stdntid,g1classtype,g1tmathss,g1treadss, g1wordskillss )

small_scores_g1 <- 
  main_data_g1 %>% filter(g1classtype=="SMALL CLASS", !is.na(g1tmathss) & !is.na(g1treadss) & !is.na(g1wordskillss) )  %>%
    select(stdntid,g1classtype,g1tmathss,g1treadss, g1wordskillss )

reg_scores_g1 <- 
  reg_scores_g1 %>% mutate(perc_maths_g1=percent_rank(g1tmathss), perc_read_g1 =percent_rank(g1treadss), perc_word_g1=percent_rank(g1wordskillss))

scores_g1 <- reg_scores_g1

for (i in 1:nrow(small_scores_g1)) {
  # select ith observation
  obs <- small_scores_g1[i,]
  # add to regular observations and compute percentile ranks
  temp <- add_row(reg_scores_g1, obs) %>% 
    mutate(perc_maths_g1=percent_rank(g1tmathss), perc_read_g1 =percent_rank(g1treadss), perc_word_g1=percent_rank(g1wordskillss))
  # add observation to merged scores
  scores_g1 <-  add_row(scores_g1, tail(temp,1))
}

scores_g1 <- 
  scores_g1 %>% mutate(perc_average_g1 = (perc_maths_g1 + perc_read_g1 + perc_word_g1)/3)

scores_g1 %>% 
  filter(g1classtype=="REGULAR CLASS" | g1classtype=="REGULAR + AIDE CLASS") %>%
    summarise(mean_av = mean(perc_average_g1), mean_math = mean(perc_maths_g1), mean_read = mean(perc_read_g1), mean_word = mean(perc_word_g1))
scores_g1 %>% 
  filter(g1classtype=="SMALL CLASS") %>%
    summarise(mean_av = mean(perc_average_g1), mean_math = mean(perc_maths_g1), mean_read = mean(perc_read_g1), mean_word = mean(perc_word_g1))
```

```{r echo=TRUE}
reg_scores_g2 <- 
  main_data_g2 %>% filter(g2classtype=="REGULAR CLASS" | g2classtype=="REGULAR + AIDE CLASS", !is.na(g2tmathss) & !is.na(g2treadss) & !is.na(g2wordskillss) )  %>%
    select(stdntid,g2classtype,g2tmathss,g2treadss, g2wordskillss )

small_scores_g2 <- 
  main_data_g2 %>% filter(g2classtype=="SMALL CLASS", !is.na(g2tmathss) & !is.na(g2treadss) & !is.na(g2wordskillss) )  %>%
    select(stdntid,g2classtype,g2tmathss,g2treadss, g2wordskillss )

reg_scores_g2 <- 
  reg_scores_g2 %>% mutate(perc_maths_g2=percent_rank(g2tmathss), perc_read_g2 =percent_rank(g2treadss), perc_word_g2=percent_rank(g2wordskillss))

scores_g2 <- reg_scores_g2

for (i in 1:nrow(small_scores_g2)) {
  # select ith observation
  obs <- small_scores_g2[i,]
  # add to regular observations and compute percentile ranks
  temp <- add_row(reg_scores_g2, obs) %>% 
    mutate(perc_maths_g2=percent_rank(g2tmathss), perc_read_g2 =percent_rank(g2treadss), perc_word_g2=percent_rank(g2wordskillss))
  # add observation to merged scores
  scores_g2 <-  add_row(scores_g2, tail(temp,1))
}

scores_g2 <- 
  scores_g2 %>% mutate(perc_average_g2 = (perc_maths_g2 + perc_read_g2 + perc_word_g2)/3)

scores_g2 %>% 
  filter(g2classtype=="REGULAR CLASS" | g2classtype=="REGULAR + AIDE CLASS") %>%
    summarise(mean_av = mean(perc_average_g2), mean_math = mean(perc_maths_g2), mean_read = mean(perc_read_g2), mean_word = mean(perc_word_g2))
scores_g2 %>% 
  filter(g2classtype=="SMALL CLASS") %>%
    summarise(mean_av = mean(perc_average_g2), mean_math = mean(perc_maths_g2), mean_read = mean(perc_read_g2), mean_word = mean(perc_word_g2))
# word has more below 0.5 means (many equal scores?)
```

```{r echo=TRUE}
reg_scores_g3 <- 
  main_data_g3 %>% filter(g3classtype=="REGULAR CLASS" | g3classtype=="REGULAR + AIDE CLASS", !is.na(g3tmathss) & !is.na(g3treadss) & !is.na(g3wordskillss) )  %>%
    select(stdntid,g3classtype,g3tmathss,g3treadss, g3wordskillss )

small_scores_g3 <- 
  main_data_g3 %>% filter(g3classtype=="SMALL CLASS", !is.na(g3tmathss) & !is.na(g3treadss) & !is.na(g3wordskillss) )  %>%
    select(stdntid, g3classtype,g3tmathss,g3treadss, g3wordskillss )

reg_scores_g3 <- 
  reg_scores_g3 %>% mutate(perc_maths_g3=percent_rank(g3tmathss), perc_read_g3 =percent_rank(g3treadss), perc_word_g3=percent_rank(g3wordskillss))

scores_g3 <- reg_scores_g3

for (i in 1:nrow(small_scores_g3)) {
  # select ith observation
  obs <- small_scores_g3[i,]
  # add to regular observations and compute percentile ranks
  temp <- add_row(reg_scores_g3, obs) %>% 
    mutate(perc_maths_g3=percent_rank(g3tmathss), perc_read_g3 =percent_rank(g3treadss), perc_word_g3=percent_rank(g3wordskillss))
  # add observation to merged scores
  scores_g3 <-  add_row(scores_g3, tail(temp,1))
}

scores_g3 <- 
  scores_g3 %>% mutate(perc_average_g3 = (perc_maths_g3 + perc_read_g3 + perc_word_g3)/3)

scores_g3 %>% 
  filter(g3classtype=="REGULAR CLASS" | g3classtype=="REGULAR + AIDE CLASS") %>%
    summarise(mean_av = mean(perc_average_g3), mean_math = mean(perc_maths_g3), mean_read = mean(perc_read_g3), mean_word = mean(perc_word_g3))
scores_g3 %>% 
  filter(g3classtype=="SMALL CLASS") %>%
    summarise(mean_av = mean(perc_average_g3), mean_math = mean(perc_maths_g3), mean_read = mean(perc_read_g3), mean_word = mean(perc_word_g3))
```

Merge all results by student ID:

```{r echo=TRUE}
scores_all <- 
  scores_gk %>% 
    full_join(scores_g1, by = "stdntid") %>% 
      full_join(scores_g2, by = "stdntid") %>% 
        full_join(scores_g3, by = "stdntid") %>% 
          select(stdntid, perc_average_g3, perc_maths_g3, perc_read_g3, perc_word_g3, perc_average_g2, perc_maths_g2, perc_read_g2, perc_word_g2, perc_average_g1, perc_maths_g1, perc_read_g1, perc_word_g1,perc_average_gk, perc_maths_gk, perc_read_gk, perc_word_gk)
# we get a problem here, because covariates are in different categories, better make a dataset with new variables and merge them with the main_data
main_data <- 
  main_data %>% full_join(scores_all, by="stdntid")

```

### Race into 3 factors: White/Asian, Black, Other

First for students:

```{r echo=TRUE}
# Change the levels of var race
main_data$race <-  recode_factor(main_data$race, `WHITE`="WHITE/ASIAN", `BLACK`="BLACK", `ASIAN`="WHITE/ASIAN", .default = "OTHER")
summary(main_data$race)
```

Secondly for teachers:

```{r echo=TRUE}
# Change the levels of var race for Teacher in Kindergarten
main_data$gktrace <-  recode_factor(main_data$gktrace, `WHITE`="WHITE/ASIAN", `BLACK`="BLACK", `ASIAN`="WHITE/ASIAN", .default = "OTHER")
summary(main_data$gtrace)
# and for 1st,2nd and 3rd Grade
main_data$g1trace <-  recode_factor(main_data$g1trace, `WHITE`="WHITE/ASIAN", `BLACK`="BLACK", `ASIAN`="WHITE/ASIAN", .default = "OTHER")
main_data$g2trace <-  recode_factor(main_data$g2trace, `WHITE`="WHITE/ASIAN", `BLACK`="BLACK", `ASIAN`="WHITE/ASIAN", .default = "OTHER")
main_data$g3trace <-  recode_factor(main_data$g3trace, `WHITE`="WHITE/ASIAN", `BLACK`="BLACK", `ASIAN`="WHITE/ASIAN", .default = "OTHER")

```



#### Plot average score by class 

```{r echo=TRUE, warning=FALSE}
p1 <- ggplot(data=subset(main_data, !is.na(g3classtype)), aes(x = g3classtype, y = perc_average_g3)) +
        geom_boxplot(fill="#4271AE",alpha = 0.7,
                     outlier.colour = "#1F3552", outlier.shape = 20, varwidth=T) +
        scale_y_continuous(name = "Test Score Average SAT",
                           breaks = seq(0, 1, 0.1),
                           limits=c(0, 1)) +
        scale_x_discrete(name = "Class Type") +
        ggtitle("Boxplot of average score by class type")
p1    

```


### Compute Entry Levels

Krüger controls for entry levels and schools, since random assignment took place within schools and there are several arguments that entry level has an effect on the strength of the treatment variable.

```{r echo=FALSE, include=FALSE}
main_data <- 
  main_data %>% 
  mutate(entry_level = ifelse(X=="YES",1,0)) %>% 
    mutate(entry_level = ifelse(X.1=="YES",2,entry_level)) %>% 
      mutate(entry_level = ifelse(X.2=="YES",3,entry_level))  %>% 
        mutate(entry_level = ifelse(X.3=="YES",4,entry_level)) 
main_data$entry_level <- factor(main_data$entry_level, labels=c("Kindergarten", "1st Grade", "2nd Grade", "3rd Grade"))
# create Fixed effects for school-by-entry-wave effects (see Krüger 2001)
# 4 levels

main_data <- 
  main_data %>% mutate(school_at_entry = ifelse(entry_level=="Kindergarten", gkschid, 0)) %>%
    mutate(school_at_entry = ifelse(entry_level=="1st Grade", g1schid, school_at_entry)) %>%
      mutate(school_at_entry = ifelse(entry_level=="2nd Grade", g2schid, school_at_entry)) %>%
        mutate(school_at_entry = ifelse(entry_level=="3rd Grade", g3schid, school_at_entry))
main_data$school_at_entry <- factor(main_data$school_at_entry) 
# attributes(main_data$school_at_entry)
# 79 levels

# make a factor variable, which combines the two informations to get an interaction effect
# this is "school_by_entry_wave variable (see Krüger 1999)
main_data$school_by_entry <- with(main_data, interaction(school_at_entry, entry_level))
# attributes(main_data$school_by_entry)
# 321 levels against 304 with Krüger
# that should work out when we control for missings in the test scores
```

### Recode Class type as a DUMMY:

This is just done for easier compution of later regression models and else.

```{r echo=TRUE}
main_data <- 
  main_data %>% mutate(smallDu = ifelse(entry_level=="Kindergarten" & gkclasstype=="SMALL CLASS",1 , ifelse(entry_level=="1st Grade" & g1classtype=="SMALL CLASS",1, ifelse(entry_level=="2nd Grade" & g2classtype=="SMALL CLASS",1, ifelse(entry_level=="3rd Grade" & g3classtype=="SMALL CLASS",1,0)))))

main_data$smallDu <- factor(main_data$smallDu, labels = c("OTHER", "SMALL"))

main_data <- 
  main_data %>% mutate(regAidDu = ifelse(entry_level=="Kindergarten" & gkclasstype=="REGULAR + AIDE CLASS",1 , ifelse(entry_level=="1st Grade" & g1classtype=="REGULAR + AIDE CLASS",1, ifelse(entry_level=="2nd Grade" & g2classtype=="REGULAR + AIDE CLASS",1, ifelse(entry_level=="3rd Grade" & g3classtype=="REGULAR + AIDE CLASS",1,0)))))

main_data$regAidDu <- factor(main_data$regAidDu, labels = c("OTHER", "RegAid"))
```

### Recode teacher education as Dummy

Following Krüger, teacher education is recoded as a DUMMY for Master degree or higher:

```{r echo=TRUE}
# create a Dummy for Master or Higher
main_data <- 
  main_data %>% 
    mutate(gktdegree = factor(ifelse(gkthighdegree=="MASTERS" |gkthighdegree=="MASTER +" | gkthighdegree=="SPECIALIST" |gkthighdegree=="DOCTORAL",1,0)), g1tdegree = factor(ifelse(g1thighdegree=="MASTERS" |g1thighdegree=="MASTER +" | g1thighdegree=="SPECIALIST" |g1thighdegree=="DOCTORAL",1,0)), g2tdegree = factor(ifelse(g2thighdegree=="MASTERS" |g2thighdegree=="MASTER +" | g2thighdegree=="SPECIALIST" |g2thighdegree=="DOCTORAL",1,0)), g3tdegree = factor(ifelse(g3thighdegree=="MASTERS" |g3thighdegree=="MASTER +" | g3thighdegree=="SPECIALIST" |g3thighdegree=="DOCTORAL",1,0)))  
```

### Recode School ID as factor variable

```{r echo=TRUE}
main_data$gkschid <- factor(main_data$gkschid)
main_data$g1schid <- factor(main_data$g1schid)
main_data$g2schid <- factor(main_data$g2schid)
main_data$g3schid <- factor(main_data$g3schid)
# attributes(main_data$gkschid)
```
Let's save the manipulated datasets for later access.

```{r echo=TRUE}
save(main_data, file = "/home/hanes/Documents/Projects/2020_Master_STAR/master20/data/main_data.RData")    
```


# EDA

### Figure 1 (Krüger 1999, p.509)

Plot Densities of average test results at each Grade

```{r echo=TRUE}
reg_scores_gk <- 
  main_data_gk %>% filter(gkclasstype=="REGULAR CLASS" | gkclasstype=="REGULAR + AIDE CLASS", !is.na(gktmathss) & !is.na(gktreadss) & !is.na(gkwordskillss) ) %>%
    select(stdntid,gkclasstype,gktmathss,gktreadss, gkwordskillss )


theme_set(theme_classic())
# Plot
g1 <- ggplot(data=subset(main_data, !is.na(perc_average_gk)), aes(perc_average_gk)) + 
  geom_density(aes(fill=factor(smallDu)), alpha=0.8) +
labs(title="Kindergarten",
caption="Source: STAR",
x="Average SAT Test Percentile Rank",
fill="Class Type")


g2 <- ggplot(data=subset(main_data, !is.na(perc_average_g1)), aes(perc_average_g1)) + 
  geom_density(aes(fill=factor(smallDu)), alpha=0.8) +
labs(title="1st Grade",
caption="Source: STAR",
x="Average SAT Test Percentile",
fill="Class Type")

g3 <- ggplot(data=subset(main_data, !is.na(perc_average_g2)), aes(perc_average_g2)) + 
  geom_density(aes(fill=factor(smallDu)), alpha=0.8) +
labs(title="2nd Grade",
caption="Source: STAR",
x="Average SAT Test Percentile",
fill="Class Type")

g4 <- ggplot(data=subset(main_data, !is.na(perc_average_g3)), aes(perc_average_g3)) + 
  geom_density(aes(fill=factor(smallDu)), alpha=0.8) +
labs(title="3nd Grade",
caption="Source: STAR",
x="Average SAT Test Percentile",
fill="Class Type")


grid.arrange(g1, g2, g3 , g4 , nrow = 2)

```

The figure is almost identical to Kügers publication. Only the curve for regular students in 3rd grade seems missing a small peak around the 0.5 percentile.


### Randomization Tests

Test consist of a regression of the dependent variable onto several demographic characteristics:

```{r echo=TRUE}
main_data <- main_data %>% mutate(Whites_Asian = ifelse(race=="WHITE" | race == "ASIAN", 1, 0 ), Small_class = ifelse(gkclasstype=="SMALL CLASS",1,0))
r_model1 <- lm(Small_class ~ Whites_Asian + gender + gkfreelunch, data = main_data) 
(summary(r_model1))
```

Demographic variables effects are non-significant and smaller then in Krügers paper. *F-Statistic* is clearly random.

We can now include *school fixed effects* using schools id's at kindergarten (assignment) level

```{r echo=TRUE}
r_model2 <- lm(Small_class ~ Whites_Asian + gender + gkfreelunch + gkschid, data = main_data) 
(summary(r_model2))
```
That doesn't seem to change the results. So let's look at *Entry-Grade-fixed effects*

```{r echo=TRUE}

r_model3 <- lm(Small_class ~ Whites_Asian + gender + gkfreelunch + gkschid + entry_level, data = main_data) 
(summary(r_model3))
```

First of all, it seems that a huge number of students entered STAR in 3rd Grade, which seems not very helpful in regard to the experimental design. Did Krüger only analyse certain cohorts? How does that change the results?

Secondly, we still seem to have random assignments to class and level-entry cohorts, but level 4 seems to inherit a problem (students are more likely to be in a SMALL class, when assigned in 3rd grade?). F-statistic is still non-significant but considerably larger than in Krügers paper (R-squared is lower though).

Lastly, let's look at teachers characteristics:

```{r echo=TRUE}
# create a Dummy for Master or Higher
main_data <- 
  main_data %>% 
    mutate(degree = ifelse(g1thighdegree=="MASTERS" |g1thighdegree=="MASTER +" | g1thighdegree=="SPECIALIST" |g1thighdegree=="DOCTORAL",1,0))  
r_model4 <- 
  lm(Small_class ~ g3tgen + degree, data = main_data) 
r_model5 <- 
  lm(Small_class ~ g2tgen + degree + gkschid + entry_level, data = main_data) 

(summary(r_model4))
(summary(r_model5))
lm(Small_class ~ g2tgen + degree + gkschid*entry_level, data = main_data) %>% tidy() 
```

**COMMENT**: Gender is not significant for teachers in grade 3, however in earlier stages it is suggesting that female teachers were less likely to be associated with small classes??

### Basic Regression Model (Table 5, Krüger 1999, p. 512)

See Krüger 1999, p. 510 for explanations:

$$
\text { (2) } \quad Y_{i c s}=\beta_{0}+\beta_{1} S M A L L_{c s}+\beta_{2} R E G / A_{c s}+\beta_{3} X_{i c s}+\alpha_{s}+\epsilon_{i c s}
$$

Following, the regression for kindergarten students are computed. In the following Models actual class type (not initial class type is used as treatment).

Model 1:

```{r echo=TRUE}
r_mod1_99 <- 
  lm(perc_average_gk ~ smallDu + regAidDu , data = main_data) 
summary(r_mod1_99)    
```


Model 2:

```{r echo=TRUE}
r_mod2_99 <- 
  lm(perc_average_gk ~ smallDu + regAidDu + gkschid, data = main_data) 
```

The results are similar to Krüger and the first model. After including *School fixed effects*, we get an R squared value of `r round(summary(r_mod2_99)$r.squared,3)`.


Model 4 (full model:

```{r echo=TRUE,  results = 'hide'}
r_mod4_99_gk <-
  lm(perc_average_gk ~ smallDu + regAidDu + race + gender + gkfreelunch  + gktrace  + gktyears + gktdegree + gkschid, data = main_data)
# we remove teachers gender; apparently there are only female teachers in kindergarten
summary(r_mod4_99_gk)
```

For the full model, we get an R squared value of `r round(summary(r_mod4_99_gk)$r.squared,3)`, which is identical to Krüger. `Gender`, `Race` and `FREE LUNCH` are significant factors at the individual level. For Teachers `Master` Dummy is not relevant, but experience in years is.

Sample Size for Krüger was 5861 for kindergarten, the estimated Model above contains 5615 observations, i.d. the coding strategy produces slightly more missings.

We repeat the regression for students with test scores in Grade 3:

```{r echo=FALSE,  results = 'hide'}
r_mod4_99_g3 <- 
  lm(perc_average_g3 ~ smallDu + regAidDu + race + gender + g3freelunch  + g3trace + g3tgen  + g3tyears + g3tdegree + g3schid, data = main_data) 
summary(r_mod4_99_g3)
```

For the full model, we get an R squared value of `r round(summary(r_mod4_99_g3)$r.squared,3)`. Again results fit to Krügers estimation. 

Sample Size for Krüger was 6109 for kindergarten, the estimated Model above contains 5641 observations, i.d. the coding strategy produces slightly more missings.

## Population characteristics [Table 1, Krüger 2001]

```{r echo=TRUE, message=FALSE}
# get relatrive shares without NAs
(minority <- main_data %>% group_by(race) %>% summarise(n = n()) %>% mutate(rel_freq=n/sum(n[1:6])))

```

**Comments**: Share of Black Students is 36.5% to 31.7% (Krüger 2001) and minorities other then Black are only `r round(sum(minority$rel_freq[3:6])*100,2)`% vs. 1.4%. 
- Depends on Entry Levels on students (here all entry levels were used)

```{r echo=TRUE, message=FALSE}
# get relatrive shares without NAs
(poverty <- main_data %>% group_by(gkfreelunch) %>% summarise(n = n()) %>% mutate(rel_freq=n/sum(n)))

```
**Comment**: It seems that Krüger interpreted NAs as *non- eligible for free-lunch*. Still his numbers are a bit lower with 24.4% to 26.3%. Ignoring the NAs results into a share of 48.4% students who are eligible for free-lunch (kindergarten level).

```{r echo=TRUE, message=FALSE}
# get relatrive shares without NAs
(teacher <- main_data %>% group_by(g3thighdegree) %>% summarise(n = n()) %>% mutate(rel_freq=n/sum(n[1:3]))) %>% filter(g3thighdegree!="NA")

```

**Comments**: Here Krüger seems to ignore NAs. Results are `r round(sum(teacher$rel_freq[2:3])*100,1)`% vs. 43.4%.

```{r echo=TRUE, message=FALSE}

(act_scores <- main_data %>% summarise(ACT_Math = mean(hsactmath,na.rm=TRUE)))
```
**Comment**: Krüger uses ACT Math Scores (instead of combined totals) and again sample results are slightly higher with Krüger indicating a sample with "smarter" students overall.


It seems that the proportions of all data points are slightly different regarding the socio-economic background of students (i.d. more missings around "poor" students?). Does this introduce a relevant selection bias?


